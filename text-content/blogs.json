{
	"blogs": [
		{
			"header": "Use Protection with Pointers",
			"author": "Weyman Kwong",
			"team"  : "Ducky",
			"date"  : ["2014", "6", "1"],
			"text"  : "WORD WRAP ON AHHHHHHHHHHHHHHHHHHHHHHHHHHH It's important to choose types that cannot be used in ways for which they weren't intended. This ensures that problems are detected earlier and that your interfaces are clean and expressive. I often think about what types tell me. Just by looking at the type of a variable (perhaps a function parameter), what can I determine about the values that it should take? Raw pointers are far too ambiguous. It is possible to use them in ways much broader than their intended use, often with terrible consequences. If you see a function with a pointer parameter, it is difficult to know what you should be passing to the function without reading its documentation. Even then, you'd better hope the documentation was correct and you are passing the correct things. The more specific we can be with our types the better, as it ensures that our code is safe, trustworthy, and easily understood. As with many things in C++, we can often achieve this with little to no run-time cost."
		}
	  ,	{
	  		"header": "I Love Pointers",
			"author": "Gandhi X",
			"team"  : "Ahimsa",
			"date"  : ["2014", "7", "29"],
			"text"  : "Pointers are commonly used to point at the first element in an array. This is necessary when an array type itself cannot be used, such as when the array has dynamic length or as the parameter of a function. The usual array indexing syntax can be applied to the pointer, so it can largely be treated as though it were an array. Using pointers in this way is ambiguous because nothing about the type actually says it's pointing at an element in an array."
		}
	]
}